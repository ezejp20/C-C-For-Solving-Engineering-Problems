{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Consolas;\f2\fnil\fcharset0 Consolas-Bold;
\f3\fnil\fcharset0 Verdana;}
{\colortbl;\red255\green255\blue255;\red159\green159\blue159;\red255\green255\blue255;\red0\green0\blue0;
\red15\green114\blue1;\red0\green0\blue255;\red10\green82\blue135;\red133\green0\blue2;\red109\green109\blue109;
\red251\green0\blue129;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid201\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{circle\}}{\leveltext\leveltemplateid202\'01\uc0\u9702 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid301\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid4}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}}
\paperw11900\paperh16840\margl1440\margr1440\vieww16220\viewh9600\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 IOSTREAM FUNCTIONS\
\

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt\clvertalbase \clshdrawnil \clwWidth560\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx4320
\clvertalt\clvertalbase \clshdrawnil \clwWidth17120\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\sl264\qr\partightenfactor0

\f1 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 1\
2\
3\
4\
5\cell 
\pard\intbl\itap1\pardeftab720\sl264\partightenfactor0
\cf4 \strokec4 seekg(0); seekg(0,ios::beg);\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \cf5 \strokec5 //sets the get pointer to the beginning.\cf4 \strokec4 \
seekg(5,ios::beg);\'a0\'a0\'a0\'a0\'a0 \cf5 \strokec5 //sets the get pointer to 5 chars forward of the beginning.\cf4 \strokec4 \
tellp(); tellg()\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \cf5 \strokec5 //returns the current value of the put/get pointer\cf4 \strokec4 \
seekp(-10,ios::end);\'a0\'a0 \cf5 \strokec5 //sets the put pointer to 10 chars before the end\cf4 \strokec4 \
seekp(1,ios::cur);\'a0\'a0\'a0\'a0\'a0 \cf5 \strokec5 //proceeds to next char\cf4 \strokec4 \
\cell \lastrow\row

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt\clvertalbase \clshdrawnil \clwWidth560\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx4320
\clvertalt\clvertalbase \clshdrawnil \clwWidth17120\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\sl264\qr\partightenfactor0
\cf2 \strokec2 1\
2\
3\
4\
5\
6\cell 
\pard\intbl\itap1\pardeftab720\sl264\partightenfactor0
\cf5 \strokec5 //Inserts var into string (like objects are displayed by \cf4 \strokec4 \
\cf5 \strokec5 // putting them to cout)\cf4 \strokec4 \
output_stream<<var;\'a0\'a0\'a0 \
\cf5 \strokec5 //Gets the value from the stream's characters positioned \cf4 \strokec4 \
\cf5 \strokec5 // after the get pointer and puts it into var.\cf4 \strokec4 \
input_stream>>var;\'a0\'a0\
\
To check if a stream is valid:\
\cell \lastrow\row

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt\clvertalbase \clshdrawnil \clwWidth560\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx4320
\clvertalt\clvertalbase \clshdrawnil \clwWidth17920\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\sl264\qr\partightenfactor0
\cf2 \strokec2 1\
2\
3\
4\
5\cell 
\pard\intbl\itap1\pardeftab720\sl264\partightenfactor0
\cf4 \strokec4 ifstream file( \cf6 \strokec6 "test.txt"\cf4 \strokec4  );\
\pard\intbl\itap1\pardeftab720\sl264\partightenfactor0

\f2\b \cf7 \strokec7 if
\f1\b0 \cf4 \strokec4  ( ! file )\
\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0cout << \cf6 \strokec6 "An error occurred opening the file"\cf4 \strokec4  << endl;\
\}\
\
\pard\intbl\itap1\tx220\tx720\pardeftab720\li720\fi-720\sl300\partightenfactor0
\ls1\ilvl0
\f3 \cf4 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 good() returns true when everything is okay.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 bad() returns true when a fatal error has occurred.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 fail() returns true after an unsuccessful stream operation like an unexpected type of input being encountered.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 eof() returns true when the end of file is reached.\cb1 \
\pard\intbl\itap1\pardeftab720\sl264\partightenfactor0

\f1 \cf4 \cb3 \
\

\itap2\trowd \taflags0 \trgaph108\trleft-108 \trcbpat3 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth27240\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadb20 \clpadr0 \gaph\cellx8640
\pard\intbl\itap2\pardeftab720\sl580\sa321\partightenfactor0

\f3\b\fs48 \cf4 \cb1 A Gentle Introduction to C++ IO Streams\
\pard\intbl\itap2\pardeftab720\sl300\partightenfactor0

\b0\fs24 \cf4 By Manasij Mukherjee\
\pard\intbl\itap2\pardeftab720\sl300\sa240\partightenfactor0
\cf4 One of the great strengths of C++ is its I/O system, IO Streams. As Bjarne Stroustrup says in his book "The C++ Programming Language", "Designing and implementing a general input/output facility for a programming language is notoriously difficult". He did an excellent job, and the C++ IOstreams library is part of the reason for C++'s success. IO streams provide an incredibly flexible yet simple way to design the input/output routines of any application.\
\pard\intbl\itap2\pardeftab720\sl300\partightenfactor0
\cf4 IOstreams can be used for a wide variety of data manipulations thanks to the following features:\
\pard\intbl\itap2\tx220\tx720\pardeftab720\li720\fi-720\sl300\partightenfactor0
\ls2\ilvl0\cf4 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 A 'stream' is internally nothing but a series of characters. The characters may be either normal characters (char) or wide characters (wchar_t). Streams provide you with a universal character-based interface to any type of storage medium (for example, a file), without requiring you to know the details of how to write to the storage medium. Any object that can be written to one type of stream, can be written to all types of streams. In other words, as long as an object has a stream representation, any storage medium can accept objects with that stream representation.\
\ls2\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 Streams work with built-in data types, and you can make user-defined types work with streams by {\field{\*\fldinst{HYPERLINK "http://www.cprogramming.com/tutorial/operator_overloading.html"}}{\fldrslt \cf8 \strokec8 overloading}} the insertion operator (<<) to put objects into streams, and the extraction operator (>>) to read objects from streams.\
\ls2\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 The stream library's unified approach makes it very friendly to use. Using a consistent interface for outputting to the screen and sending files over a network makes life easier. The programs below will show you what is possible.\
\pard\intbl\itap2\pardeftab720\sl300\sa240\partightenfactor0
\cf4 The IO stream class hierarchy is quite complicated, so rather than introduce you to the full hierarchy at this point, I'll start with explaining the concepts of the design and show you examples of streams in action. Once you are familiar with elements of the design and how to apply those concepts to design a robust I/O system for your software, an understanding of what belongs where in the hierarchy will come naturally.\
\pard\intbl\itap2\pardeftab720\sl440\sa298\partightenfactor0

\b\fs36 \cf4 What do input and output really mean?\
\pard\intbl\itap2\pardeftab720\sl300\sa240\partightenfactor0

\b0\fs24 \cf4 To get a good idea about what input and output are, think of information as a stream of characters. This makes sense because whatever we enter through a keyboard can only be characters. Suppose the user enters the number 7479....WAIT...! How do you know the user entered a number? The problem is that you don't really know. All you have is a set of 4 characters: '7', '4', '7' and '9'. It is completely up to you, the programmer, whether you want the input to be a number, to be a string, or to be fodder for /dev/random; whether the characters can be valid for the desired type totally depends upon whether that type can interpret the characters in the input stream as a description for an object of that type.\
You have to get the input characters into a recognizable data type for them to be of any use other than as a character array.\
IO streams not only define the relation between a stream of characters and the standard data types but also allows you to define a relationship between a stream of characters and your own classes. It also allows you nearly limitless freedom to manipulate those streams both using object oriented interfaces and working directly on character buffers when necessary. (Of course some of the lower level manipulations may be undefined; for example, you can't probe forward into an input stream to see the future!)\
\pard\intbl\itap2\pardeftab720\sl440\sa298\partightenfactor0

\b\fs36 \cf4 How do streams work?\
\pard\intbl\itap2\pardeftab720\sl300\sa240\partightenfactor0

\b0\fs24 \cf4 Streams are serial interfaces to storage, buffers files, or any other storage medium. The difference between storage media is intentionally hidden by the interface; you may not even know what kind of storage you're working with but the interface is exactly the same.\
The "serial" nature of streams is a very important element of their interface. You cannot directly make random access random reads or writes in a stream (unlike, say, using an array index to access any value you want) although you can seek to a position in a stream and perform a read at that point.\
Using a serial representation gives a consistent interface for all devices. Many devices have the capability of both producing and consuming data at the same time; if data is being continually produced, the simplest way to think about reading that data is by doing a fetch of the next characters in a stream. If that data hasn't been produced yet (the user hasn't typed anything, or the network is still busy processing a packet), you wait for more data to become available, and the read will return that data. Even if you try to seek past the end (or beginning) of a stream, the stream pointer (i.e. get or put pointer) will remain at the boundary, making the situation safe. (Compare this with accessing data off the end of an array, where the behavior is undefined.)\
The underlying low-level interface that corresponds to the actual medium very closely is a character buffer (the stream buffer, technically called the streambuf), which can be thought of as the backbone of the stream. Being a buffer, it does not hold the entire content of the stream, if the stream is large enough, so you can't use it for random access.\
The most important of the basic stream operations are:\
\pard\intbl\itap2\tx220\tx720\pardeftab720\li720\fi-720\sl300\partightenfactor0
\ls3\ilvl0\cf4 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	1.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 First, the stream is initialized with the appropriate type (like a std::string for a stringstream and the filename for an fstream) of values and suitable modes (like ios::in for input and ios::out for output and many more depending on the type of the stream).\
\ls3\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	2.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 After that, you can specify where the I/O should occur, through the get and put pointers. Depending on how you open the stream, the location may already be set appropriately (for example, if you open a file with ios::app, your get pointer set at the end of the stream, allowing appends).The member functions associated with setting the get and put pointers are:\
\pard\intbl\itap2\tx940\tx1440\pardeftab720\li1440\fi-1440\sl300\partightenfactor0
\ls3\ilvl1\cf4 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 seekg()and seekp() for .dragging. the get and put pointer, respectively, to the position specified. Both seek methods take an argument (of type streampos) providing a position in the file relative to the beginning of the file (using ios::beg), the end of the file (using ios::end), or the current position (using ios::cur). You may also provide just a specific location, such as io::beg, for the beginning of the file.\
\ls3\ilvl1\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 tellg() and tellp() provide the current location of the get and put pointers, respectively\
\pard\intbl\itap2\tx220\tx720\pardeftab720\li720\fi-720\sl300\sa240\partightenfactor0
\ls3\ilvl0\cf4 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	3.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 The following one-liners should clear up most questions:\

\itap3\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt\clvertalbase \clshdrawnil \clwWidth560\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx4320
\clvertalt\clvertalbase \clshdrawnil \clwWidth17120\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx8640
\pard\intbl\itap3\tx220\tx720\pardeftab720\li720\fi-720\sl264\qr\partightenfactor0
\ls3\ilvl0
\f1 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	4.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 1\uc0\u8232 2\u8232 3\u8232 4\u8232 5\u8232 \cb1 \nestcell 
\pard\intbl\itap3\tx220\tx720\pardeftab720\li720\fi-720\sl264\partightenfactor0
\ls3\ilvl0\cf4 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	5.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 seekg(0); seekg(0,ios::beg);\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \cf5 \strokec5 //sets the get pointer to the beginning.\cf4 \strokec4 \uc0\u8232 seekg(5,ios::beg);\'a0\'a0\'a0\'a0\'a0 \cf5 \strokec5 //sets the get pointer to 5 chars forward of the beginning.\cf4 \strokec4 \uc0\u8232 tellp(); tellg()\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \cf5 \strokec5 //returns the current value of the put/get pointer\cf4 \strokec4 \uc0\u8232 seekp(-10,ios::end);\'a0\'a0 \cf5 \strokec5 //sets the put pointer to 10 chars before the end\cf4 \strokec4 \uc0\u8232 seekp(1,ios::cur);\'a0\'a0\'a0\'a0\'a0 \cf5 \strokec5 //proceeds to next char\cf4 \strokec4 \uc0\u8232 \cb1 \uc0\u8232 \nestcell 
\pard\intbl\itap3\tx220\tx720\pardeftab720\li720\fi-720\sl300\partightenfactor0
\ls3\ilvl0
\f3 \cf4 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	6.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 \uc0\u8232 \cb1 \uc0\u8232 N.B: Be careful when seeking the put pointer into the middle of in the stream. If you put anything in the stream, it will go directly into the stream at the put location, overwriting the previous contents. In other words, if you need to insert data in the middle of a stream, you have to manually move the data that would be overwritten. As a side note, if you're finding yourself doing that too often, then you may want to use a string representation of your data, which can simplify this kind of random access operation.\u8232 \nestcell 
\pard\intbl\itap3\nestcell \lastrow\nestrow
\pard\intbl\itap2\tx220\tx720\pardeftab720\li720\fi-720\sl300\partightenfactor0
\ls3\ilvl0\cf4 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	7.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 Once you're at the right location in the stream, input and output is done through the << and >> operators. If you want to input an object to the stream, use the << operator; for output, use >>. The class for your object must, of course, have provided overloads for these methods. Here's a short example:\

\itap3\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt\clvertalbase \clshdrawnil \clwWidth560\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx4320
\clvertalt\clvertalbase \clshdrawnil \clwWidth17120\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx8640
\pard\intbl\itap3\tx220\tx720\pardeftab720\li720\fi-720\sl264\qr\partightenfactor0
\ls3\ilvl0
\f1 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	8.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 1\uc0\u8232 2\u8232 3\u8232 4\u8232 5\u8232 6\u8232 \cb1 \nestcell 
\pard\intbl\itap3\tx220\tx720\pardeftab720\li720\fi-720\sl264\partightenfactor0
\ls3\ilvl0\cf5 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	9.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec5 //Inserts var into string (like objects are displayed by \cf4 \strokec4 \uc0\u8232 \cf5 \strokec5 // putting them to cout)\cf4 \strokec4 \uc0\u8232 output_stream<<var;\'a0\'a0\'a0 \u8232 \cf5 \strokec5 //Gets the value from the stream's characters positioned \cf4 \strokec4 \uc0\u8232 \cf5 \strokec5 // after the get pointer and puts it into var.\cf4 \strokec4 \uc0\u8232 input_stream>>var;\'a0\'a0\'a0\'a0\'a0 \u8232 \cb1 \uc0\u8232 \nestcell 
\pard\intbl\itap3\tx220\tx720\pardeftab720\li720\fi-720\sl300\partightenfactor0
\ls3\ilvl0
\f3 \cf4 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	10.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 \uc0\u8232 \cb1 \uc0\u8232 If var is an object (either a built in class or a user defined type), the exact process of the input or output is dependent on the overloaded >> or << operator respectively.\u8232 \nestcell 
\pard\intbl\itap3\nestcell \lastrow\nestrow
\pard\intbl\itap2\pardeftab720\sl440\sa298\partightenfactor0

\b\fs36 \cf4 Error handling with IO streams\
\pard\intbl\itap2\pardeftab720\sl300\sa240\partightenfactor0

\b0\fs24 \cf4 Handling errors gracefully is important for building a robust system. The 'errors' or 'signals' (e.g., reaching the end of the file) in this case generally occur when a stream encounters something it didn't expect.\
Whether a stream is currently valid can be checked by simply by using the stream as a Boolean:\

\itap3\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt\clvertalbase \clshdrawnil \clwWidth560\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx4320
\clvertalt\clvertalbase \clshdrawnil \clwWidth17920\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx8640
\pard\intbl\itap3\pardeftab720\sl264\qr\partightenfactor0

\f1 \cf2 \cb3 \strokec2 1\
2\
3\
4\
5\nestcell 
\pard\intbl\itap3\pardeftab720\sl264\partightenfactor0
\cf4 \strokec4 ifstream file( \cf6 \strokec6 "test.txt"\cf4 \strokec4  );\

\f2\b \cf7 \strokec7 if
\f1\b0 \cf4 \strokec4  ( ! file )\
\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0cout << \cf6 \strokec6 "An error occurred opening the file"\cf4 \strokec4  << endl;\
\}\nestcell \lastrow\nestrow
\pard\intbl\itap2\pardeftab720\sl300\sa240\partightenfactor0

\f3 \cf4 \cb1 More detailed status of the stream can be obtained using the good(), bad(), fail() and eof() functions. The clear() function will reset the stream and clear the error, which is necessary to perform any further IO on the stream.\
\pard\intbl\itap2\tx220\tx720\pardeftab720\li720\fi-720\sl300\partightenfactor0
\ls4\ilvl0\cf4 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 good() returns true when everything is okay.\
\ls4\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 bad() returns true when a fatal error has occurred.\
\ls4\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 fail() returns true after an unsuccessful stream operation like an unexpected type of input being encountered.\
\ls4\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 eof() returns true when the end of file is reached.\
\pard\intbl\itap2\tx566\pardeftab720\sl300\partightenfactor0
\cf4 \
\
\pard\intbl\itap2\pardeftab720\sl300\sa240\partightenfactor0
\cf4 You can detect that a particular read or write operation failed by testing the result of the read. For example, to check that a valid integer is read from the user, you can do this:\

\itap3\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt\clvertalbase \clshdrawnil \clwWidth560\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx4320
\clvertalt\clvertalbase \clshdrawnil \clwWidth17920\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx8640
\pard\intbl\itap3\pardeftab720\sl264\qr\partightenfactor0

\f1 \cf2 \cb3 \strokec2 1\
2\
3\
4\
5\nestcell 
\pard\intbl\itap3\pardeftab720\sl264\partightenfactor0

\f2\b \cf9 \strokec9 int
\f1\b0 \cf4 \strokec4  x;\

\f2\b \cf7 \strokec7 if
\f1\b0 \cf4 \strokec4  ( cin >> x ) \
\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0cout << \cf6 \strokec6 "Please enter a valid number"\cf4 \strokec4  << endl;\
\}\
\
\
\pard\intbl\itap3\pardeftab720\sl440\sa298\partightenfactor0

\f3\b\fs36 \cf4 An example of creating a stream-enabled object\
\pard\intbl\itap3\pardeftab720\sl300\sa240\partightenfactor0

\b0\fs24 \cf4 Here is a simple example of an utility designed for writing out logfile entries from command line arguments that takes advantage of some important stream facilities. If you don't understand something, refer to the tutorial on that particular topic.\

\itap4\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt\clvertalbase \clshdrawnil \clwWidth700\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx4320
\clvertalt\clvertalbase \clshdrawnil \clwWidth17780\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx8640
\pard\intbl\itap4\pardeftab720\sl264\qr\partightenfactor0

\f1 \cf2 \strokec2 1\
2\
3\
4\
5\
6\
7\
8\
9\
10\
11\
12\
13\
14\
15\
16\
17\
18\
19\
20\
21\
22\
23\
24\
25\
26\
27\
28\
29\
30\
31\
32\
33\
34\
35\
36\
37\
38\
39\
40\
41\
42\
43\
44\
45\
46\
47\
48\
49\
50\
51\
52\
53\
54\
55\
56\
57\
58\
59\
60\
61\
62\
63\
64\
65\
66\
67\
68\
69\
70\
71\
72\
73\
74\
75\
76\
77\
78\
79\
80\
81\
82\nestcell 
\pard\intbl\itap4\pardeftab720\sl264\partightenfactor0
\cf9 \strokec9 #include <iostream>\cf4 \strokec4 \
\cf9 \strokec9 #include <ctime>\cf4 \strokec4 \
\cf9 \strokec9 #include <sstream>\cf4 \strokec4 \
\cf9 \strokec9 #include <fstream>\cf4 \strokec4 \
\'a0\

\f2\b \cf7 \strokec7 using
\f1\b0 \cf4 \strokec4  
\f2\b \cf7 \strokec7 namespace
\f1\b0 \cf4 \strokec4  std;\
\'a0\
\cf5 \strokec5 // timestamp returns the current time as a string \cf4 \strokec4 \
std::string timestamp();\'a0\'a0\'a0 \
\'a0\

\f2\b \cf7 \strokec7 class
\f1\b0 \cf4 \strokec4  LogStatement;\
ostream& operator<<(ostream& ost, 
\f2\b \cf7 \strokec7 const
\f1\b0 \cf4 \strokec4  LogStatement& ls);\
\'a0\

\f2\b \cf7 \strokec7 class
\f1\b0 \cf4 \strokec4  LogStatement\
\{\

\f2\b \cf7 \strokec7 public
\f1\b0 \cf4 \strokec4 :\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0LogStatement(std::string s): data(s), time_string( timestamp() )\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\{ \};\
\'a0\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 //This method handles all the outputs.\'a0\'a0\'a0 \cf4 \strokec4 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f2\b \cf7 \strokec7 friend
\f1\b0 \cf4 \strokec4  ostream& operator<<(ostream&, 
\f2\b \cf7 \strokec7 const
\f1\b0 \cf4 \strokec4  LogStatement&);\'a0\'a0 \

\f2\b \cf7 \strokec7 private
\f1\b0 \cf4 \strokec4 :\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0std::string data;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0std::string time_string;\
\'a0\'a0\'a0\'a0\
\};\
\'a0\
ostream& operator<<(ostream& ost, 
\f2\b \cf7 \strokec7 const
\f1\b0 \cf4 \strokec4  LogStatement& ls)\
\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0ost<<\cf6 \strokec6 "~|"\cf4 \strokec4 <<ls.time_string<<\cf6 \strokec6 '|'\cf4 \strokec4 <<ls.data<<\cf6 \strokec6 "|~"\cf4 \strokec4 ;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f2\b \cf7 \strokec7 return
\f1\b0 \cf4 \strokec4  ost;\
\}\
\'a0\
std::string timestamp() \
\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 //Notice the use of a stringstream, yet another useful stream medium!\cf4 \strokec4 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0ostringstream stream;\'a0\'a0\'a0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f2\b \cf9 \strokec9 time_t
\f1\b0 \cf4 \strokec4  rawtime;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f2\b \cf9 \strokec9 tm
\f1\b0 \cf4 \strokec4  * timeinfo;\
\'a0\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f2\b \cf10 \strokec10 time
\f1\b0 \cf4 \strokec4 (&rawtime);\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0timeinfo = 
\f2\b \cf10 \strokec10 localtime
\f1\b0 \cf4 \strokec4 ( &rawtime );\
\'a0\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0stream << (timeinfo->tm_year)+1900<<\cf6 \strokec6 " "\cf4 \strokec4 <<timeinfo->tm_mon\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0<<\cf6 \strokec6 " "\cf4 \strokec4 <<timeinfo->tm_mday<<\cf6 \strokec6 " "\cf4 \strokec4 <<timeinfo->tm_hour\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0<<\cf6 \strokec6 " "\cf4 \strokec4 <<timeinfo->tm_min<<\cf6 \strokec6 " "\cf4 \strokec4 <<timeinfo->tm_sec;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 // The str() function of output stringstreams return a std::string.\cf4 \strokec4 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f2\b \cf7 \strokec7 return
\f1\b0 \cf4 \strokec4  stream.str();\'a0\'a0 \
\}\
\'a0\

\f2\b \cf9 \strokec9 int
\f1\b0 \cf4 \strokec4  main(
\f2\b \cf9 \strokec9 int
\f1\b0 \cf4 \strokec4  argc, 
\f2\b \cf9 \strokec9 char
\f1\b0 \cf4 \strokec4 ** argv)\
\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f2\b \cf7 \strokec7 if
\f1\b0 \cf4 \strokec4 (argc<2)\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 // A return of -1 denotes an error condition.\cf4 \strokec4 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f2\b \cf7 \strokec7 return
\f1\b0 \cf4 \strokec4  -1;\'a0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0ostringstream log_data;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 // This takes all the char arrays in the argv \cf4 \strokec4 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 // (except the filename) and produces a stream.\cf4 \strokec4 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f2\b \cf7 \strokec7 for
\f1\b0 \cf4 \strokec4 (
\f2\b \cf9 \strokec9 int
\f1\b0 \cf4 \strokec4  i=1;i<argc;i++)\'a0\'a0\'a0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0log_data<<argv[i]<<\cf6 \strokec6 ' '\cf4 \strokec4 ; \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}\
\'a0\'a0\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0LogStatement log_entry(log_data.str());\
\'a0\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0clog<<log_entry<<endl;\
\'a0\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0ofstream logfile(\cf6 \strokec6 "logfile"\cf4 \strokec4 ,ios::app);\
\'a0\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 // check for errors opening the file\cf4 \strokec4 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f2\b \cf7 \strokec7 if
\f1\b0 \cf4 \strokec4  ( ! logfile )\'a0\'a0\'a0\'a0\'a0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f2\b \cf7 \strokec7 return
\f1\b0 \cf4 \strokec4  -1;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}\'a0\'a0\'a0\'a0\'a0\'a0 \
\'a0\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0logfile<<log_entry<<endl;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0logfile.close();\
\'a0\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f2\b \cf7 \strokec7 return
\f1\b0 \cf4 \strokec4  0;\
\}\nestcell \lastrow\nestrow
\pard\intbl\itap3\pardeftab720\sl264\partightenfactor0
\cf4 \
\
\pard\intbl\itap3\pardeftab720\sl300\sa240\partightenfactor0

\f3 \cf4 Here is a very very simple example of writing to a file:\

\itap4\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt\clvertalbase \clshdrawnil \clwWidth700\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx4320
\clvertalt\clvertalbase \clshdrawnil \clwWidth17780\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx8640
\pard\intbl\itap4\pardeftab720\sl264\qr\partightenfactor0

\f1 \cf2 \strokec2 1\
2\
3\
4\
5\
6\
7\
8\
9\
10\
11\
12\
13\
14\nestcell 
\pard\intbl\itap4\pardeftab720\sl264\partightenfactor0
\cf9 \strokec9 #include <iostream>\cf4 \strokec4 \
\cf9 \strokec9 #include <fstream>\cf4 \strokec4 \
\'a0\

\f2\b \cf7 \strokec7 using
\f1\b0 \cf4 \strokec4  
\f2\b \cf7 \strokec7 namespace
\f1\b0 \cf4 \strokec4  std;\
\'a0\

\f2\b \cf9 \strokec9 int
\f1\b0 \cf4 \strokec4  main()\
\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0ofstream ofs(\cf6 \strokec6 "a.txt"\cf4 \strokec4 ,ios::app);\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f2\b \cf7 \strokec7 if
\f1\b0 \cf4 \strokec4 (ofs.good())\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0ofs<<\cf6 \strokec6 "Hello a.txt, I'm appending this on you."\cf4 \strokec4 ;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f2\b \cf7 \strokec7 return
\f1\b0 \cf4 \strokec4  0;\
\}\nestcell \lastrow\nestrow
\pard\intbl\itap3\pardeftab720\sl264\partightenfactor0
\cf4 \
\
\pard\intbl\itap3\pardeftab720\sl300\sa240\partightenfactor0

\f3 \cf4 You can, for example, open a string in a stringstream, extract a floating point number from it to do some operations, and put it back in the stream.\

\itap4\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt\clvertalbase \clshdrawnil \clwWidth700\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx4320
\clvertalt\clvertalbase \clshdrawnil \clwWidth17780\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx8640
\pard\intbl\itap4\pardeftab720\sl264\qr\partightenfactor0

\f1 \cf2 \strokec2 1\
2\
3\
4\
5\
6\
7\
8\
9\
10\
11\
12\
13\
14\
15\
16\
17\
18\
19\
20\
21\
22\
23\
24\
25\
26\nestcell 
\pard\intbl\itap4\pardeftab720\sl264\partightenfactor0
\cf9 \strokec9 #include <iostream>\cf4 \strokec4 \
\cf9 \strokec9 #include <sstream>\cf4 \strokec4 \
\'a0\

\f2\b \cf7 \strokec7 using
\f1\b0 \cf4 \strokec4  
\f2\b \cf7 \strokec7 namespace
\f1\b0 \cf4 \strokec4  std;\
\'a0\

\f2\b \cf9 \strokec9 int
\f1\b0 \cf4 \strokec4  main()\
\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0stringstream my_stream(ios::in|ios::out);\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0std::string dat(\cf6 \strokec6 "Hey, I have a double : 74.79 ."\cf4 \strokec4 );\
\'a0\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0my_stream.str(dat);\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0my_stream.seekg(-7,ios::end);\
\'a0\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f2\b \cf9 \strokec9 double
\f1\b0 \cf4 \strokec4  val;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0my_stream>>val;\
\'a0\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0val= val*val;\
\'a0\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0my_stream.seekp(-7,ios::end);\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0my_stream<<val;\
\'a0\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0std::string new_val = my_stream.str();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0cout<<new_val;\
\'a0\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f2\b \cf7 \strokec7 return
\f1\b0 \cf4 \strokec4  0;\
\}\nestcell \lastrow\nestrow
\pard\intbl\itap3\pardeftab720\sl264\partightenfactor0
\cf4 \
\pard\intbl\itap3\pardeftab720\sl300\sa240\partightenfactor0

\f3 \cf4 Here is a very simple example of copying a file efficiently with those buffers (thankfully, no ultra-complicated manipulation is involved here!).\

\itap4\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt\clvertalbase \clshdrawnil \clwWidth700\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx4320
\clvertalt\clvertalbase \clshdrawnil \clwWidth17780\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx8640
\pard\intbl\itap4\pardeftab720\sl264\qr\partightenfactor0

\f1 \cf2 \strokec2 1\
2\
3\
4\
5\
6\
7\
8\
9\
10\
11\
12\
13\
14\
15\
16\nestcell 
\pard\intbl\itap4\pardeftab720\sl264\partightenfactor0
\cf9 \strokec9 #include <iostream>\cf4 \strokec4 \
\cf9 \strokec9 #include <fstream>\cf4 \strokec4 \

\f2\b \cf7 \strokec7 using
\f1\b0 \cf4 \strokec4  
\f2\b \cf7 \strokec7 namespace
\f1\b0 \cf4 \strokec4  std;\
\'a0\

\f2\b \cf9 \strokec9 int
\f1\b0 \cf4 \strokec4  main()\
\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0ifstream ifs(\cf6 \strokec6 "a.txt"\cf4 \strokec4 );\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\cf5 \strokec5 //ios::trunc means that the output file will be overwritten if exists \cf4 \strokec4 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0ofstream ofs(\cf6 \strokec6 "a.txt.copy"\cf4 \strokec4 , ios::trunc);\'a0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f2\b \cf7 \strokec7 if
\f1\b0 \cf4 \strokec4  (ifs &&\'a0 ofs )\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0ofs<<ifs.rdbuf();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}\
\'a0\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f2\b \cf7 \strokec7 return
\f1\b0 \cf4 \strokec4  0;\
\}\nestcell \lastrow\nestrow
\pard\intbl\itap3\pardeftab720\sl264\partightenfactor0
\cf4 \
\
\nestcell \lastrow\nestrow\nestcell \lastrow\nestrow
\pard\intbl\itap1\pardeftab720\sl264\partightenfactor0
\cf4 \
\
\cell \lastrow\row
}